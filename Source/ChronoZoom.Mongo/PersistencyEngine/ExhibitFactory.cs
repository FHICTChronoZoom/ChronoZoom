using Chronozoom.Business.Repositories;
using ChronoZoom.Mongo.Models;
using MongoDB.Bson;
using MongoDB.Bson.Serialization.Attributes;
using MongoDB.Driver;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ChronoZoom.Mongo.PersistencyEngine
{
    public class ExhibitFactory
    {
        private const string COLLECTION_NAME = "exhibit";

        public ExhibitFactory() { }

        /// <summary>
        /// Find an exhibit by it's id
        /// </summary>
        /// <param name="exhibitId"></param>
        /// <returns></returns>
        public async Task<Exhibit> FindByIdAsync(Guid exhibitId)
        {
            var collection = MongoFactory.database.GetCollection<Exhibit>(COLLECTION_NAME);
            var exhibit = await collection.Find<Exhibit>(x => x.Id == exhibitId).FirstOrDefaultAsync();

            return exhibit;
        }

        internal Task<List<Exhibit>> FindByTimelineIdAsync(Guid timelineId)
        {
            // TODO : Implement this method for MongoDB (Blame rik for not communicating this and letter the error stay).
            throw new NotImplementedException();
        }


        /// <summary>
        /// Insert an exhibit
        /// </summary>
        /// <param name="exhibit">The exhibit to be inserted</param>
        /// <returns>A boolean which indicated whether the insertion was succesful</returns>
        public async Task<Boolean> InsertAsync(Exhibit exhibit) 
        {
            var collection = MongoFactory.database.GetCollection<Exhibit>(COLLECTION_NAME);
            await collection.InsertOneAsync(exhibit);

            return true;
        }

        /// <summary>
        /// Update an exhibit.
        /// For now, we update the entire user object. This is not ideal and definitely not the neatest way
        /// to do this. But it's fast and it's effective.
        /// @TODO this should take the Library.Models.Exhibit model and update it in the database
        /// using our own model. Conversion between those models should be written here.
        /// </summary>
        /// <param name="exhibit">The updated Exhibit Object</param>
        /// <returns>ReplaceOneResult generated by the MongoDB server</returns>
        public async Task<Boolean> UpdateAsync(Exhibit exhibit)
        {
            var collection = MongoFactory.database.GetCollection<Exhibit>(COLLECTION_NAME);
            var result = await collection.ReplaceOneAsync<Exhibit>(x => x.Id.Equals(exhibit.Id), exhibit, new UpdateOptions { IsUpsert = true });

            return true;
        }

        /// <summary>
        /// Deletes an exhibit from the database. permanently.
        /// </summary>
        /// <param name="exhibit">The Exhibit object to be deleted</param>
        /// <returns>DeleteResult generated by the MongoDB server</returns>
        public async Task<Boolean> DeleteAsync(Guid exhibit)
        {
            var collection = MongoFactory.database.GetCollection<Exhibit>(COLLECTION_NAME);
            var result = await collection.DeleteOneAsync<Exhibit>(x => x.Id.Equals(exhibit));
            
            return true;
        }
    }
}
